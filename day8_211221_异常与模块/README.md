# 1. 复习

- 递归：少用
- 文件读取的相关操作：r、w、a
- read, readline, readlines(几乎不用)
- close()
- 读取写入保持一样的字符集(utf8、GBK……)
- 文件读取模式：三大类各四种
- 文件的复制、备份，二进制不使用encoding
- 相对路径、绝对路径

# 2. 异常

- ##### 出现异常后，程序会终止运行，在异常代码之后的所有代码将不会继续执行

- ##### try中的代码一般情况下不会抛出异常，所以一般情况下不会执行except中的代码

- ##### 在异常出现后处理异常，防止影响正常代码运行

- ##### 异常捕获的基本形式：

  ```python
  try:
    可能出现异常的代码块
  except:
    try中出现异常时执行的代码块
  ```

  1. try中代码块如果出现异常代码，异常代码之后所有代码不会继续执行
  2. try中代码出现异常立即执行except中代码
  3. try中代码出现异常不会终止程序运行
  4. try…except…执行结束后将继续向下运行

- ##### 捕获指定异常：

  ```python
  try:
    print(a)	# NameError: name 'a' is not defined
  except NameError:
    print('出现NameError异常')
  print('程序结束')
  ```

  如果try中出现的是except中书写的异常类型，则可以被捕获，否则不能被捕获，程序依然终止运行

- ##### 捕获多个异常：只能捕获到第一个出现的异常

  ​	方法1：当捕获多个异常时，可以把要捕获的异常类型的名字放到except 后，并使用元组的方式进行书写

  ​	方法2：并列书写except

  ```python
  # 方法1
  try:
      print(1/0)
  except (NameError, ZeroDivisionError):
      print('有错误')
  # 方法2
  try:
      print(1/0)
  except NameError:
      print('有错误')
  except ZeroDivisionError:
    	print('有错误')
  ```

- ##### 捕获异常描述信息：except xxxError as ==name==

  ```python
  try:
      print(num)
  except (NameError, ZeroDivisionError) as result:
      print(result)
  ```

- ##### 捕获所有异常：Exception是所有异常类的父类

- ##### else: 当try中的代码全部执行完毕没有出现任何异常时，会执行else中的命令

- ##### 将代码写入else可以增强代码的可读性

- ##### 在开发中，要使try中代码尽可能少

- ##### finally：在所有的try……except……else……代码结束后都会执行finally，无论是否出现异常，将finally中代码写出finally效果不变

- ##### finally增强可读性，提高逻辑严谨性

- ##### finally无论如何都被执行，关闭文件、日志处理、崩溃日志采集都可以使用，我称之为最后的倔强

- ##### 异常的传递（异常穿透）：

  1. 有异常捕获的嵌套
  2. 内层try无法捕获到指定异常，外层try会继续捕获
  3. 异常捕获时，从内向外一层层的传递没有捕获成功地异常的过程叫做异常传递，或者异常穿透

  ```python
  try:
      file = open('java.txt', 'r', encoding='utf8')
      try:
          print(file.read())
          print(a)
      except NameError:
          print('数据类型错误')
  except FileNotFoundError as error:
      print(error)
      print('该文件不存在')
      open('java.txt', 'w', encoding='utf8')
  except Exception as e:
      print(e)
      print('出现未知异常')
  else:
      print('牛逼')
  ```

  

# 3. 模块

- ##### 模块是一个Python文件，这个文件中的函数，类，对象，全局变量等可以导入其他文件内进行使用，增强代码的复用性

- ##### 可以使用import关键字将模块进行导入，但命名必须符合标识符命名规则

- ##### 模块导入和使用：

  1. import 模块名 (全部导入)

     - 调用：模块名.功能名

     - 全部导入下，模块中所有的功能都可以被使用

  2. from 模块名 import 功能名

     - 调用：直接使用功能名
     - 这种方式又叫做**局部导入**，并且只能使用被导入的功能

  3. from 模块名 import *

     - 调用：直接使用功能名
     - 也是局部导入，* 是通配符，表示所有可以被导入的功能
     - `__all__`可以限制导入的内容

  4. import 模块名 as 模块别名

     - 调用：模块别名.功能名
     - 如果给模块起了别名，只能使用别名，不能使用原名称

  5. from 模块名 import 功能名 as 功能别名

     - 调用：使用功能别名
     - 如果给功能起了别名，只能使用别名，不能使用原名称

- ##### 在Python中，不建议一次性导入多个模块，建议分行写

- ##### 可以一次性导入多个功能

- ##### 模块的查询顺序：(sys.path)在开发中先从当前所在位置查询，如果没有该模块，则在工程目录查询，如果工程目录中也没有，则去系统目录中查询，如果都没有则报错

- ##### 自定义模块：

  - 命名要遵循标识符命名规则
  - 只有类、全局变量、函数定义等可以导入其他文件
  - 导入模块时，会将模块中所有代码全部执行一遍，此时，全局变量、函数等会保存到内存中等待使用
  - 导入模块时会生成二进制缓存文件，如果不修改模块，下次导入时则执行pyc文件，提高执行效率

- ##### `__all__`: 当`__all__`存在时，from 模块名 import * 只能导入`__all__`这个列表内添加的功能，如果其中添加了不存在的功能，则在导包时会报错。

  - 其只能约束from 模块名 import * 这种导入形式
  - 习惯性写在开头
  - 使用原因：可以约束from import *，因为from import *不可以给功能名称起别名

# 4. 包

- ##### 创建一个包文件

  - 创建一个文件夹，并且在文件夹内创建一个`__init__.py`文件
  - 直接创建一个Python package

- ##### 导入并使用包

  - import 包名.模块名

    调用：包名.模块名.功能名

  - from 包名 import 模块名 (全部导入)

  - from 包名.模块名 import 功能名

  - from 包名.模块名 import *

    会受all限制

  - from 包名 import *

    必须在`__init__.py`里写入`__all__`列表

    如果init文件里不写all列表，则包中模块都不能被使用

  - import 包名

    直接导入包，如果有all列表，则可以使用其中的所有模块

    直接导入包，会执行init中的代码，所以在init中导入的模块，在import包名的时候也能使用

- ##### 导入工程目录中的模块，直接导入模块名即可

- ##### 如果在导入模块时，不知道怎么导，就从工程目录中进行导入，一层一层进行导入

- ##### 如果直接导入当前目录下的模块，且当前目录不是工程目录，pycharm错误检测就会认为你导入方式不对，有两种方法可以解决此问题：

  1. 从工程目录开始导入
  2. 让当前目录编程资源路径：mark directory as >> source root

- ##### Python官方建议所有的导包路径从工程目录开始，尽量不要使用其他的目录

# 5. 测试模块

- 如果我们想导入某个模块，模块内部输出语句，导入模块时，会直接输出

- 在开发中希望的是导入模块时没有任何效果产生，只有调用功能时才会出现效果

- 如果不希望在导入模块时执行输出、循环、判断等，可以将测试代码写到main中

  ```python
  if __name__ == '__main__':
      print()
  ```